<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Slither Arena</title>
  <style>
    :root {
      --bg: radial-gradient(circle at 20% 20%, rgba(60, 80, 180, 0.12), transparent 32%),
            radial-gradient(circle at 80% 0%, rgba(255, 80, 140, 0.1), transparent 30%),
            #04050a;
      --panel: rgba(0, 0, 0, 0.55);
      --panel-stroke: rgba(255, 255, 255, 0.1);
      --text: #f3f6ff;
      --muted: #9eabc0;
      --glow: #39ffe0;
      --gold: #fbd45a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: transparent;
    }
    .hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      color: var(--text);
      font-weight: 600;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
    }
    .board {
      position: absolute;
      top: 14px;
      left: 16px;
      background: var(--panel);
      border: 1px solid var(--panel-stroke);
      border-radius: 14px;
      padding: 12px;
      width: min(260px, 46vw);
      backdrop-filter: blur(10px);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45), inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .board-title {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .board-row {
      display: grid;
      grid-template-columns: 24px 1fr 56px;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.04);
      align-items: center;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }
    .board-row span:last-child { text-align: right; }
    .board-row.you {
      background: rgba(57, 255, 224, 0.1);
      border-color: rgba(57, 255, 224, 0.35);
    }
    .score-pill {
      position: absolute;
      top: 16px;
      right: 18px;
      font-size: clamp(26px, 4vw, 38px);
      padding: 12px 18px;
      background: linear-gradient(135deg, #f8d65a, #f5a144);
      color: #1b1000;
      border-radius: 14px;
      box-shadow: 0 18px 40px rgba(248, 214, 90, 0.35), inset 0 0 0 1px rgba(255, 255, 255, 0.4);
      pointer-events: none;
    }
    .timer {
      position: absolute;
      bottom: 18px;
      right: 18px;
      padding: 10px 14px;
      background: var(--panel);
      border: 1px solid var(--panel-stroke);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      font-size: 15px;
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.38);
    }
    .modal {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.65);
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
      z-index: 20;
    }
    .modal.show {
      visibility: visible;
      opacity: 1;
      pointer-events: auto;
    }
    .modal-card {
      background: #0b0d15;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 18px;
      padding: 20px 24px;
      min-width: 320px;
      box-shadow: 0 22px 60px rgba(0, 0, 0, 0.6), inset 0 0 0 1px rgba(255, 255, 255, 0.04);
      text-align: center;
    }
    .modal h2 { margin: 6px 0 14px; letter-spacing: 0.5px; }
    .modal .stat-line { display: flex; justify-content: space-between; margin: 6px 0; color: var(--muted); }
    .btn {
      margin-top: 12px;
      padding: 12px 16px;
      font-size: 15px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      background: linear-gradient(135deg, #5dffcb, #4ac8ff);
      color: #041019;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.4), 0 0 24px rgba(93, 255, 203, 0.35);
    }
    .btn:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud">
    <div class="board">
      <div class="board-title">Top snakes</div>
      <div id="leaderboard"></div>
    </div>
    <div class="score-pill">Score: <span id="score">0</span></div>
    <div class="timer">‚è± <span id="timer">0:00</span></div>
  </div>
  <div class="modal" id="gameOver">
    <div class="modal-card">
      <h2>Game Over</h2>
      <div class="stat-line"><span>Final Score</span><strong id="finalScore">0</strong></div>
      <div class="stat-line"><span>Time Alive</span><strong id="finalTime">0:00</strong></div>
      <button class="btn" id="playAgain">Play Again</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let viewW = window.innerWidth;
    let viewH = window.innerHeight;
    canvas.width = viewW;
    canvas.height = viewH;

    const WORLD_SIZE = 4000;
    const FOOD_COUNT = 300;
    const BOT_COUNT = 15;
    const BASE_RADIUS = 10;
    const SEGMENT_SPACING = 16;
    const PLAYER_SPEED = 3.5;
    const BOT_SPEED_MIN = 2;
    const BOT_SPEED_MAX = 3.5;
    const COLLISION_DIST = BASE_RADIUS * 1.8;

    const foodEmojis = ['üçé','üçí','üçá','üçâ','üçè','üçä','üçã','üçë','üçì','üçå','üç™','üç©','üßÄ','üçî','ü•ï','üçû','üçç','üçê','ü•ù','üç´'];
    const palettes = [
      ['#ff7ad1', '#ff4fa3', '#ffa0d7'],
      ['#7ad1ff', '#4fa3ff', '#9fe1ff'],
      ['#6aff9f', '#3ce086', '#c4ffd7'],
      ['#ffb15a', '#ff7b42', '#ffd8a3'],
      ['#9f7aff', '#7448ff', '#cbb5ff'],
      ['#ff6f61', '#ff9a76', '#ffc2a1'],
      ['#5dffcb', '#39ffe0', '#8fffe5'],
      ['#ff5b83', '#ff3d5b', '#ffa3b9'],
      ['#7eff7a', '#52e06e', '#d6ffd4'],
      ['#52d7ff', '#2fa9ff', '#9bdcff']
    ];

    const names = [
      'DemureSurveillance38','DesperateGuse3009','LucrativeSanctity277','HermanLatif','NervousJunior26',
      'UndeservedDanger61','Liam Byrne','CaramelBlockade68','BacterialPinnacle55','Guest_209446651',
      'AdeptOpal','SilentRibbon','VividOrbit','CrimsonTrail','MintyMeteor'
    ];

    const leaderboardEl = document.getElementById('leaderboard');
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const modal = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const finalTimeEl = document.getElementById('finalTime');
    const playAgainBtn = document.getElementById('playAgain');

    let foods = [];
    let snakes = [];
    let player;
    let particles = [];
    let lastTime = performance.now();
    let running = true;
    let gameStart = performance.now();
    let gameOver = false;
    let audioCtx = null;

    const mouse = { x: viewW / 2, y: viewH / 2 };
    window.addEventListener('mousemove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    window.addEventListener('resize', () => {
      viewW = window.innerWidth;
      viewH = window.innerHeight;
      canvas.width = viewW;
      canvas.height = viewH;
    });

    function rand(min, max) { return Math.random() * (max - min) + min; }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function createSnake(name, palette, isPlayer = false) {
      const x = rand(300, WORLD_SIZE - 300);
      const y = rand(300, WORLD_SIZE - 300);
      const len = 10;
      const segments = Array.from({ length: len }, (_, i) => ({ x: x - i * SEGMENT_SPACING, y, angle: 0 }));
      return {
        id: Math.random().toString(36).slice(2) + Date.now().toString(36),
        name,
        palette,
        segments,
        desiredSegments: len,
        radius: BASE_RADIUS,
        speed: isPlayer ? PLAYER_SPEED : rand(BOT_SPEED_MIN, BOT_SPEED_MAX),
        angle: 0,
        score: 0,
        isPlayer,
        target: { x, y },
        dead: false
      };
    }

    function resetGame() {
      foods = [];
      snakes = [];
      player = createSnake('You', palettes[0], true);
      snakes.push(player);
      for (let i = 0; i < BOT_COUNT; i++) {
        const name = names[i % names.length];
        const palette = palettes[(i + 1) % palettes.length];
        snakes.push(createSnake(name, palette, false));
      }
      for (let i = 0; i < FOOD_COUNT; i++) foods.push(randomFood());
      running = true;
      gameOver = false;
      gameStart = performance.now();
      modal.classList.remove('show');
      updateHUD(0);
    }

    function randomFood() {
      return {
        x: rand(50, WORLD_SIZE - 50),
        y: rand(50, WORLD_SIZE - 50),
        emoji: foodEmojis[Math.floor(Math.random() * foodEmojis.length)]
      };
    }

    function update(dt) {
      if (!running) return;
      snakes.forEach(snake => {
        if (snake.dead) return;
        if (snake.isPlayer) controlPlayer(snake, dt);
        else controlBot(snake, dt);
      });
      snakes.forEach(snake => {
        if (!snake.dead) handleFood(snake);
      });
      snakes.forEach((snake, i) => {
        if (snake.dead) return;
        checkCollisions(snake, i);
      });
      snakes.forEach(snake => {
        if (snake.dead && !snake.isPlayer) respawnBot(snake);
      });
      updateParticles(dt);
      const elapsed = performance.now() - gameStart;
      updateHUD(elapsed);
    }

    function controlPlayer(snake, dt) {
      const head = snake.segments[0];
      const cam = getCamera();
      const worldMouse = {
        x: cam.x + (mouse.x - viewW / 2),
        y: cam.y + (mouse.y - viewH / 2)
      };
      const angle = Math.atan2(worldMouse.y - head.y, worldMouse.x - head.x);
      snake.angle = angle;
      advanceSnake(snake, angle, dt);
    }

    function controlBot(snake, dt) {
      const head = snake.segments[0];
      const targetFood = findNearestFood(head, 280);
      if (targetFood) {
        snake.angle = Math.atan2(targetFood.y - head.y, targetFood.x - head.x);
      } else {
        snake.angle += rand(-0.2, 0.2) * dt;
      }
      advanceSnake(snake, snake.angle, dt);
    }

    function advanceSnake(snake, angle, dt) {
      const move = snake.speed * dt;
      const head = snake.segments[0];
      const nx = clamp(head.x + Math.cos(angle) * move, snake.radius, WORLD_SIZE - snake.radius);
      const ny = clamp(head.y + Math.sin(angle) * move, snake.radius, WORLD_SIZE - snake.radius);
      snake.segments[0] = { x: nx, y: ny, angle };
      for (let i = 1; i < snake.segments.length; i++) {
        const prev = snake.segments[i - 1];
        const curr = snake.segments[i];
        const dx = prev.x - curr.x;
        const dy = prev.y - curr.y;
        const dist = Math.hypot(dx, dy) || 0.0001;
        if (dist > SEGMENT_SPACING) {
          const t = (dist - SEGMENT_SPACING) / dist;
          curr.x += dx * t;
          curr.y += dy * t;
        }
        curr.angle = Math.atan2(prev.y - curr.y, prev.x - curr.x);
      }
      while (snake.segments.length < snake.desiredSegments) {
        const last = snake.segments[snake.segments.length - 1];
        snake.segments.push({ x: last.x, y: last.y, angle: last.angle });
      }
      if (snake.segments.length > snake.desiredSegments) {
        snake.segments.length = snake.desiredSegments;
      }
    }

    function handleFood(snake) {
      const head = snake.segments[0];
      for (let i = foods.length - 1; i >= 0; i--) {
        const food = foods[i];
        const dx = head.x - food.x;
        const dy = head.y - food.y;
        if (dx * dx + dy * dy < (snake.radius + 8) ** 2) {
          foods.splice(i, 1);
          foods.push(randomFood());
          snake.desiredSegments += 2;
          const gain = snake.isPlayer ? 20 : 15;
          snake.score += gain;
          spawnParticles(head.x, head.y, snake.palette, 14, 7);
          if (snake.isPlayer) playEat();
        }
      }
    }

    function findNearestFood(head, range) {
      let best = null;
      let bestDist = range * range;
      for (const food of foods) {
        const dx = head.x - food.x;
        const dy = head.y - food.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestDist) {
          bestDist = d2;
          best = food;
        }
      }
      return best;
    }

    function checkCollisions(snake, idx) {
      const head = snake.segments[0];
      for (let i = 0; i < snakes.length; i++) {
        const other = snakes[i];
        if (other.dead) continue;
        for (let j = 0; j < other.segments.length; j++) {
          if (other === snake && j < 10) continue;
          const seg = other.segments[j];
          const dx = head.x - seg.x;
          const dy = head.y - seg.y;
          if (dx * dx + dy * dy < COLLISION_DIST * COLLISION_DIST) {
            killSnake(snake);
            return;
          }
        }
      }
    }

    function killSnake(snake) {
      snake.dead = true;
      spawnParticles(snake.segments[0].x, snake.segments[0].y, snake.palette, 32, 10);
      if (snake.isPlayer) playDeath();
      if (snake.isPlayer) {
        running = false;
        gameOver = true;
        finalScoreEl.textContent = snake.score;
        finalTimeEl.textContent = timerEl.textContent;
        modal.classList.add('show');
      }
    }

    function respawnBot(snake) {
      const palette = palettes[Math.floor(Math.random() * palettes.length)];
      const fresh = createSnake(snake.name, palette, false);
      snake.segments = fresh.segments;
      snake.desiredSegments = fresh.desiredSegments;
      snake.radius = fresh.radius;
      snake.speed = fresh.speed;
      snake.angle = fresh.angle;
      snake.score = 0;
      snake.target = fresh.target;
      snake.dead = false;
    }

    function getCamera() {
      const head = player.segments[0];
      return {
        x: clamp(head.x, viewW / 2, WORLD_SIZE - viewW / 2),
        y: clamp(head.y, viewH / 2, WORLD_SIZE - viewH / 2)
      };
    }

    function draw() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, viewW, viewH);
      const cam = getCamera();
      ctx.save();
      ctx.translate(viewW / 2 - cam.x, viewH / 2 - cam.y);

      drawBackground(cam);
      drawFoods(cam);
      snakes.forEach(snake => { if (!snake.dead) drawSnake(snake); });
      drawParticles();

      ctx.restore();
    }

    function drawBackground(cam) {
      ctx.fillStyle = '#06070d';
      ctx.fillRect(0, 0, WORLD_SIZE, WORLD_SIZE);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      const step = 120;
      const startX = Math.floor((cam.x - viewW / 2) / step) * step - step * 2;
      const endX = cam.x + viewW / 2 + step * 2;
      const startY = Math.floor((cam.y - viewH / 2) / step) * step - step * 2;
      const endY = cam.y + viewH / 2 + step * 2;
      for (let x = startX; x < endX; x += step) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      for (let y = startY; y < endY; y += step) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
    }

    function drawFoods() {
      const cam = getCamera();
      const margin = Math.max(viewW, viewH);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '20px sans-serif';
      foods.forEach(food => {
        const sx = food.x - cam.x + viewW / 2;
        const sy = food.y - cam.y + viewH / 2;
        if (sx < -margin || sx > viewW + margin || sy < -margin || sy > viewH + margin) return;
        ctx.save();
        ctx.shadowColor = 'rgba(255, 255, 255, 0.45)';
        ctx.shadowBlur = 12;
        ctx.fillText(food.emoji, food.x, food.y);
        ctx.restore();
      });
    }

    function spawnParticles(x, y, palette, count = 12, size = 6) {
      for (let i = 0; i < count; i++) {
        const ang = rand(0, Math.PI * 2);
        const spd = rand(2.5, 6);
        particles.push({
          x, y,
          vx: Math.cos(ang) * spd,
          vy: Math.sin(ang) * spd,
          life: rand(420, 780),
          size: rand(size * 0.6, size * 1.2),
          color: palette[Math.floor(Math.random() * palette.length)]
        });
      }
    }

    function updateParticles(dt) {
      const decay = dt * 16.67;
      particles = particles.filter(p => {
        p.life -= decay;
        if (p.life <= 0) return false;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.985;
        p.vy *= 0.985;
        return true;
      });
    }

    function drawParticles() {
      const cam = getCamera();
      ctx.save();
      particles.forEach(p => {
        const alpha = Math.max(0, Math.min(1, p.life / 800));
        const r = p.size * (0.6 + 0.4 * (p.life / 800));
        const g = ctx.createRadialGradient(p.x, p.y, 1, p.x, p.y, r);
        g.addColorStop(0, `${p.color}cc`);
        g.addColorStop(1, `${p.color}00`);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    function ensureAudio() {
      if (!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch (e) { audioCtx = null; }
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playTone(freq, duration = 0.1, volume = 0.08) {
      ensureAudio();
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(volume, now + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + duration + 0.05);
    }

    function playEat() {
      playTone(760, 0.09, 0.08);
    }

    function playDeath() {
      playTone(180, 0.25, 0.12);
      setTimeout(() => playTone(120, 0.3, 0.1), 80);
    }

    function drawSnake(snake) {
      const cam = getCamera();
      const margin = Math.max(viewW, viewH) * 0.8;
      const cols = snake.palette;
      for (let i = snake.segments.length - 1; i >= 0; i--) {
        const seg = snake.segments[i];
        const sx = seg.x - cam.x + viewW / 2;
        const sy = seg.y - cam.y + viewH / 2;
        if (sx < -margin || sx > viewW + margin || sy < -margin || sy > viewH + margin) continue;
        const angle = seg.angle;
        const r = snake.radius;
        const g = ctx.createLinearGradient(seg.x - r, seg.y - r, seg.x + r, seg.y + r);
        g.addColorStop(0, cols[0]);
        g.addColorStop(0.5, cols[1]);
        g.addColorStop(1, cols[2]);
        ctx.save();
        ctx.shadowColor = `${cols[1]}55`;
        ctx.shadowBlur = 14;
        ctx.translate(seg.x, seg.y);
        ctx.rotate(angle);
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.ellipse(0, 0, r * 1.1, r * 0.9, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.beginPath();
        ctx.arc(-r * 0.2, -r * 0.2, 3, 0, Math.PI * 2);
        ctx.fill();
        if (i === 0) drawHeadExtras(r);
        ctx.restore();
      }
      const head = snake.segments[0];
      const nameY = head.y - snake.radius * 2.2;
      ctx.save();
      ctx.translate(head.x, nameY);
      ctx.textAlign = 'center';
      ctx.font = 'bold 13px "Segoe UI", sans-serif';
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillText(snake.name, 1, 1);
      ctx.fillStyle = '#ffffff';
      ctx.fillText(snake.name, 0, 0);
      ctx.restore();
    }

    function drawHeadExtras(r) {
      ctx.fillStyle = '#f8f9ff';
      ctx.beginPath();
      ctx.arc(r * 0.2, -r * 0.3, 4, 0, Math.PI * 2);
      ctx.arc(r * 0.2, r * 0.3, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#0b1220';
      const eyeOffset = 1.8;
      ctx.beginPath();
      ctx.arc(r * 0.2 + eyeOffset, -r * 0.3, 2.2, 0, Math.PI * 2);
      ctx.arc(r * 0.2 + eyeOffset, r * 0.3, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    function updateHUD(elapsedMs) {
      scoreEl.textContent = player.score;
      const totalSeconds = Math.floor(elapsedMs / 1000);
      const mins = Math.floor(totalSeconds / 60);
      const secs = (totalSeconds % 60).toString().padStart(2, '0');
      timerEl.textContent = `${mins}:${secs}`;

      const sorted = [...snakes].sort((a, b) => b.score - a.score).slice(0, 10);
      leaderboardEl.innerHTML = sorted.map((s, i) => `
        <div class="board-row ${s.isPlayer ? 'you' : ''}">
          <span>${i + 1}.</span>
          <span>${s.name}</span>
          <span style="text-align:right;">${s.score}</span>
        </div>
      `).join('');
    }

    function loop(now) {
      const dt = (now - lastTime) / 16.67;
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener('pointerdown', ensureAudio, { once: true });
    window.addEventListener('keydown', ensureAudio, { once: true });
    playAgainBtn.addEventListener('click', () => {
      modal.classList.remove('show');
      resetGame();
    });

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
